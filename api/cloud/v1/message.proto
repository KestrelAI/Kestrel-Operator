syntax = "proto3";

package cloud.v1;

import "google/protobuf/timestamp.proto";

option go_package = "operator/api/cloud/v1";

// Action types for resource operations
enum Action {
  ACTION_UNSPECIFIED = 0;
  ACTION_CREATE = 1;
  ACTION_UPDATE = 2;
  ACTION_DELETE = 3;
}

// Request message for flow stream
message StreamDataRequest {
  oneof request {
    Flow flow = 1;
    NetworkPolicy network_policy = 2;
    NetworkPoliciesWithErrors network_policy_with_errors = 3;
    Workload workload = 4;
    Namespace namespace = 5;
    InventoryCommit inventory_commit = 6;
    KubernetesAPIResponse kubernetes_api_response = 7;
    Service service = 8;
  }
}

message NetworkPoliciesWithErrors {
  repeated NetworkPolicyWithError policies = 1;
}

message NetworkPolicyWithError {
  string network_policy = 1;
  string error_message = 2;
  string policy_id = 3; // Unique identifier for tracking policies, generated by the server as a uuid
}

message Flow {
  string src_ip = 1;
  string dst_ip = 2;

  // Source endpoint details
  Endpoint src = 3;

  // Destination endpoint details
  Endpoint dst = 4;

  // Direction from source's viewpoint (ingress or egress)
  string direction = 5;

  // Dst port number
  uint32 port = 6;

  // Protocol (TCP, UDP, etc.)
  string protocol = 7;

  // Whether the connection was allowed
  bool allowed = 8;

  // Count of times this flow was observed
  int64 count = 9;

  // When this flow was first seen
  google.protobuf.Timestamp first_seen = 10;

  // When this flow was last seen
  google.protobuf.Timestamp last_seen = 11;

  repeated Policy ingress_allowed_by = 12;
  repeated Policy egress_allowed_by = 13;
}

// Endpoint definition for source or destination
message Endpoint {
  // Namespace
  string ns = 1;

  // Kind (Deployment, StatefulSet, etc.)
  string kind = 2;

  // Resource name
  string name = 3;

  // Digest of labels attached to the resource
  repeated string labels = 4;
}

// Policy definition used in Cilium flows
message Policy {
  string name = 1;
  string namespace = 2;
  repeated string labels = 3;
  uint64 revision = 4;
  string kind = 5;
}

// Response message
message StreamDataResponse {
  oneof response {
    // Simple acknowledgment when message is received
    Ack ack = 1;
    // Network policy when computation is complete
    NetworkPolicyWithError network_policy = 2;
    // Kubernetes API request from server to operator
    KubernetesAPIRequest kubernetes_api_request = 3;
  }
}

// Simple acknowledgment message
message Ack {}

// Workload definition for streaming workload inventory
message Workload {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  string kind = 4; // Deployment, StatefulSet, DaemonSet, etc.
  map<string, string> labels = 5;
  google.protobuf.Timestamp created_at = 6;
  Action action = 7; // CREATE, UPDATE, DELETE
}

// Namespace definition for streaming namespace inventory
message Namespace {
  string name = 1;
  string uid = 2;
  map<string, string> labels = 3;
  google.protobuf.Timestamp created_at = 4;
  Action action = 5; // CREATE, UPDATE, DELETE
}

// Service definition for streaming service inventory
message Service {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  map<string, string> labels = 4;
  map<string, string> annotations = 5;
  map<string, string> selector = 6; // Service selector labels
  repeated ServicePort ports = 7;
  string service_type = 8; // ClusterIP, NodePort, LoadBalancer, ExternalName
  string cluster_ip = 9;
  repeated string external_ips = 10;
  google.protobuf.Timestamp created_at = 11;
  Action action = 12; // CREATE, UPDATE, DELETE
}

// Service port definition
message ServicePort {
  string name = 1;
  string protocol = 2; // TCP, UDP, SCTP
  int32 port = 3;
  int32 target_port = 4; // Can be port number or named port
  int32 node_port = 5; // Only for NodePort and LoadBalancer services
}

// InventoryCommit signals that the operator has finished sending initial inventory
// and the server can now commit the staged changes and start processing incremental updates
message InventoryCommit {
}

// Network policy definition matching Kubernetes NetworkPolicy format
message NetworkPolicy {
  string api_version = 1; // networking.k8s.io/v1, cilium.io/v2, etc.
  string kind = 2;

  // Standard Kubernetes metadata
  ObjectMeta metadata = 3;
  NetworkPolicySpec spec = 4;

  // Zero-or-more "target" workloads protected by this policy;
  // each entry in the target_workloads list is of the format: "<Namespace>.<Kind>.<Name>".
  repeated string target_workloads = 5;

  // Action performed on this network policy
  Action action = 6; // CREATE, UPDATE, DELETE
}

// Kubernetes ObjectMeta
message ObjectMeta {
  string name = 1;
  string namespace = 2;
  map<string, string> labels = 3;
  map<string, string> annotations = 4;
  string resource_version = 5;
  string uid = 6;
}

// NetworkPolicy specification
message NetworkPolicySpec {
  // Selects the pods to which this NetworkPolicy object applies
  LabelSelector pod_selector = 1;

  // List of ingress rules to be applied
  repeated NetworkPolicyIngressRule ingress = 2;

  // List of egress rules to be applied
  repeated NetworkPolicyEgressRule egress = 3;

  // List of rule types that the NetworkPolicy relates to
  // Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"]
  repeated string policy_types = 4;
}

// Label selector for Kubernetes resources
message LabelSelector {
  map<string, string> match_labels = 1;
  repeated LabelSelectorRequirement match_expressions = 2;
}

message LabelSelectorRequirement {
  string key = 1;
  string operator = 2; // In, NotIn, Exists, DoesNotExist
  repeated string values = 3;
}

// NetworkPolicy ingress rule
message NetworkPolicyIngressRule {
  repeated NetworkPolicyPeer from = 1;
  repeated NetworkPolicyPort ports = 2;
}

// NetworkPolicy egress rule
message NetworkPolicyEgressRule {
  repeated NetworkPolicyPeer to = 1;
  repeated NetworkPolicyPort ports = 2;
}

// NetworkPolicy peer
message NetworkPolicyPeer {
  // Either pod_selector, namespace_selector, or ip_block should be specified
  LabelSelector pod_selector = 1;
  LabelSelector namespace_selector = 2;
  IPBlock ip_block = 3;
}

// IP CIDR block specification
message IPBlock {
  string cidr = 1;
  repeated string except = 2;
}

// NetworkPolicy port rule
message NetworkPolicyPort {
  // Protocol is optional; if not specified, applies to all protocols
  string protocol = 1; // TCP, UDP, SCTP, etc.

  // Port is optional; if not specified, matches all ports
  oneof port_value {
    int32 port = 2;
    string port_name = 3; // Named port on pods
  }

  // Port range (Kubernetes extension)
  int32 end_port = 4;
}

// Kubernetes API request message for executing K8s API calls
message KubernetesAPIRequest {
  // Unique identifier for tracking this request
  string request_id = 1;
  
  // List of Kubernetes API paths to execute
  // Format: "api/v1/namespaces/default/pods"
  repeated string api_paths = 2;
  
  // Optional timeout for the entire batch of requests (in seconds)
  int32 timeout_seconds = 3;
}

// Individual API call result
message KubernetesAPIResult {
  // The API path that was called
  string api_path = 1;
  
  // Whether this specific call succeeded
  bool success = 2;
  
  // JSON response from K8s API (if successful)
  string response_data = 3;
  
  // Error message for this specific call (if failed)
  string error_message = 4;
  
  // HTTP status code returned by K8s API
  int32 status_code = 5;
}

// Kubernetes API response message containing results
message KubernetesAPIResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Results for each individual API call
  repeated KubernetesAPIResult results = 2;
  
  // Any global error message (e.g., auth failure, operator issues)
  string global_error_message = 3;
}

// Service definition with bi-directional streaming RPC
service StreamService {
  // Bi-directional streaming RPC
  rpc StreamData(stream StreamDataRequest) returns (stream StreamDataResponse) {}
}
