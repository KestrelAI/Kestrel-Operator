syntax = "proto3";

package cloud.v1;

import "google/protobuf/timestamp.proto";

option go_package = "operator/api/cloud/v1";

// Action types for resource operations
enum Action {
  ACTION_UNSPECIFIED = 0;
  ACTION_CREATE = 1;
  ACTION_UPDATE = 2;
  ACTION_DELETE = 3;
}

// Request message for flow stream
message StreamDataRequest {
  oneof request {
    Flow flow = 1;
    NetworkPolicy network_policy = 2;
    NetworkPoliciesWithErrors network_policy_with_errors = 3;
    Workload workload = 4;
    Namespace namespace = 5;
    InventoryCommit inventory_commit = 6;
    KubernetesAPIResponse kubernetes_api_response = 7;
    Service service = 8;
    ShellCommandResponse shell_command_response = 9;
    L7AccessLog l7_access_log = 10;
    AuthorizationPolicy authorization_policy = 11;
    YamlDryRunResponse yaml_dry_run_response = 12;
    YamlApplyResponse yaml_apply_response = 13;
    Pod pod = 14;
    CertificateRenewalResponse certificate_renewal_response = 15;
    OperatorRestartResponse operator_restart_response = 16;
    Node node = 17;
    KubernetesEvent kubernetes_event = 18;
    PodStatusChange pod_status_change = 19;
    NodeConditionChange node_condition_change = 20;
    WorkloadRolloutStatus workload_rollout_status = 21;
    PodLogs pod_logs = 22;
    // OTEL metrics (for future cloud forwarding if needed)
    OTelMetricBatch otel_metric_batch = 23;
    // Response to server's metrics query
    MetricsQueryResponse metrics_query_response = 24;
  }
}

message NetworkPoliciesWithErrors {
  repeated NetworkPolicyWithError policies = 1;
}

message NetworkPolicyWithError {
  string network_policy = 1;
  string error_message = 2;
  string policy_id = 3; // Unique identifier for tracking policies, generated by the server as a uuid
}

message Flow {
  string src_ip = 1;
  string dst_ip = 2;

  // Source endpoint details
  Endpoint src = 3;

  // Destination endpoint details
  Endpoint dst = 4;

  // Direction from source's viewpoint (ingress or egress)
  string direction = 5;

  // Dst port number
  uint32 port = 6;

  // Protocol (TCP, UDP, etc.)
  string protocol = 7;

  // Whether the connection was allowed
  bool allowed = 8;

  // Count of times this flow was observed
  int64 count = 9;

  // When this flow was first seen
  google.protobuf.Timestamp first_seen = 10;

  // When this flow was last seen
  google.protobuf.Timestamp last_seen = 11;

  repeated Policy ingress_allowed_by = 12;
  repeated Policy egress_allowed_by = 13;
}

// Endpoint definition for source or destination
message Endpoint {
  // Namespace
  string ns = 1;

  // Kind (Deployment, StatefulSet, etc.)
  string kind = 2;

  // Resource name
  string name = 3;

  // Digest of labels attached to the resource
  repeated string labels = 4;
}

// Policy definition used in Cilium flows
message Policy {
  string name = 1;
  string namespace = 2;
  repeated string labels = 3;
  uint64 revision = 4;
  string kind = 5;
}

// Response message
message StreamDataResponse {
  oneof response {
    // Simple acknowledgment when message is received
    Ack ack = 1;
    // Network policy when computation is complete
    NetworkPolicyWithError network_policy = 2;
    // Kubernetes API request from server to operator
    KubernetesAPIRequest kubernetes_api_request = 3;
    // Shell command request from server to operator
    ShellCommandRequest shell_command_request = 4;
    // YAML dry-run validation request from server to operator
    YamlDryRunRequest yaml_dry_run_request = 5;
    // YAML apply request from server to operator
    YamlApplyRequest yaml_apply_request = 6;
    // Certificate renewal request from server to operator
    CertificateRenewalRequest certificate_renewal_request = 7;
    // Operator restart request from server to operator
    OperatorRestartRequest operator_restart_request = 8;
    // Server queries operator for metrics
    MetricsQueryRequest metrics_query_request = 9;
  }
}

// Simple acknowledgment message
message Ack {}

// Workload definition for streaming workload inventory
message Workload {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  string kind = 4; // Deployment, StatefulSet, DaemonSet, etc.
  map<string, string> labels = 5;
  google.protobuf.Timestamp created_at = 6;
  Action action = 7; // CREATE, UPDATE, DELETE
  string service_account = 8; // Service account used by the workload
}

// Namespace definition for streaming namespace inventory
message Namespace {
  string name = 1;
  string uid = 2;
  map<string, string> labels = 3;
  google.protobuf.Timestamp created_at = 4;
  Action action = 5; // CREATE, UPDATE, DELETE
}

// Pod definition for streaming pod inventory
message Pod {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  string pod_ip = 4; // Pod IP address
  map<string, string> labels = 5;
  string phase = 6; // Pod phase (Pending, Running, Succeeded, Failed, Unknown)
  repeated OwnerReference owner_references = 7;
  google.protobuf.Timestamp created_at = 8;
  Action action = 9; // CREATE, UPDATE, DELETE
}

// Node definition for streaming node inventory (for VPC Flow Logs IP resolution)
message Node {
  string name = 1;
  string uid = 2;
  map<string, string> labels = 3;
  repeated string internal_ips = 4; // Internal IP addresses of the node
  repeated string external_ips = 5; // External IP addresses of the node (if any)
  string hostname = 6; // Node hostname
  bool ready = 7; // Whether the node is ready
  string instance_type = 8; // Instance type (e.g., m6i.large)
  string zone = 9; // Availability zone (e.g., us-west-1a)
  google.protobuf.Timestamp created_at = 10;
  Action action = 11; // CREATE, UPDATE, DELETE
}

// OwnerReference definition
message OwnerReference {
  string api_version = 1;
  string kind = 2;
  string name = 3;
  string uid = 4;
  bool controller = 5;
  bool block_owner_deletion = 6;
}

// Service definition for streaming service inventory
message Service {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  map<string, string> labels = 4;
  map<string, string> annotations = 5;
  map<string, string> selector = 6; // Service selector labels
  repeated ServicePort ports = 7;
  string service_type = 8; // ClusterIP, NodePort, LoadBalancer, ExternalName
  string cluster_ip = 9;
  repeated string external_ips = 10;
  google.protobuf.Timestamp created_at = 11;
  Action action = 12; // CREATE, UPDATE, DELETE
}

// Service port definition
message ServicePort {
  string name = 1;
  string protocol = 2; // TCP, UDP, SCTP
  int32 port = 3;
  int32 target_port = 4; // Can be port number or named port
  int32 node_port = 5; // Only for NodePort and LoadBalancer services
}

// InventoryCommit signals that the operator has finished sending initial inventory
// and the server can now commit the staged changes and start processing incremental updates
message InventoryCommit {
}

// Network policy definition matching Kubernetes NetworkPolicy format
message NetworkPolicy {
  string api_version = 1; // networking.k8s.io/v1, cilium.io/v2, etc.
  string kind = 2;

  // Standard Kubernetes metadata
  ObjectMeta metadata = 3;
  NetworkPolicySpec spec = 4;

  // Zero-or-more "target" workloads protected by this policy;
  // each entry in the target_workloads list is of the format: "<Namespace>.<Kind>.<Name>".
  repeated string target_workloads = 5;

  // Action performed on this network policy
  Action action = 6; // CREATE, UPDATE, DELETE
}

// Kubernetes ObjectMeta
message ObjectMeta {
  string name = 1;
  string namespace = 2;
  map<string, string> labels = 3;
  map<string, string> annotations = 4;
  string resource_version = 5;
  string uid = 6;
}

// NetworkPolicy specification
message NetworkPolicySpec {
  // Selects the pods to which this NetworkPolicy object applies
  LabelSelector pod_selector = 1;

  // List of ingress rules to be applied
  repeated NetworkPolicyIngressRule ingress = 2;

  // List of egress rules to be applied
  repeated NetworkPolicyEgressRule egress = 3;

  // List of rule types that the NetworkPolicy relates to
  // Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"]
  repeated string policy_types = 4;
}

// Label selector for Kubernetes resources
message LabelSelector {
  map<string, string> match_labels = 1;
  repeated LabelSelectorRequirement match_expressions = 2;
}

message LabelSelectorRequirement {
  string key = 1;
  string operator = 2; // In, NotIn, Exists, DoesNotExist
  repeated string values = 3;
}

// NetworkPolicy ingress rule
message NetworkPolicyIngressRule {
  repeated NetworkPolicyPeer from = 1;
  repeated NetworkPolicyPort ports = 2;
}

// NetworkPolicy egress rule
message NetworkPolicyEgressRule {
  repeated NetworkPolicyPeer to = 1;
  repeated NetworkPolicyPort ports = 2;
}

// NetworkPolicy peer
message NetworkPolicyPeer {
  // Either pod_selector, namespace_selector, or ip_block should be specified
  LabelSelector pod_selector = 1;
  LabelSelector namespace_selector = 2;
  IPBlock ip_block = 3;
}

// IP CIDR block specification
message IPBlock {
  string cidr = 1;
  repeated string except = 2;
}

// NetworkPolicy port rule
message NetworkPolicyPort {
  // Protocol is optional; if not specified, applies to all protocols
  string protocol = 1; // TCP, UDP, SCTP, etc.

  // Port is optional; if not specified, matches all ports
  oneof port_value {
    int32 port = 2;
    string port_name = 3; // Named port on pods
  }

  // Port range (Kubernetes extension)
  int32 end_port = 4;
}

// Kubernetes API request message for executing K8s API calls
message KubernetesAPIRequest {
  // Unique identifier for tracking this request
  string request_id = 1;
  
  // List of Kubernetes API paths to execute
  // Format: "api/v1/namespaces/default/pods"
  repeated string api_paths = 2;
  
  // Optional timeout for the entire batch of requests (in seconds)
  int32 timeout_seconds = 3;
}

// Individual API call result
message KubernetesAPIResult {
  // The API path that was called
  string api_path = 1;
  
  // Whether this specific call succeeded
  bool success = 2;
  
  // JSON response from K8s API (if successful)
  string response_data = 3;
  
  // Error message for this specific call (if failed)
  string error_message = 4;
  
  // HTTP status code returned by K8s API
  int32 status_code = 5;
}

// Kubernetes API response message containing results
message KubernetesAPIResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Results for each individual API call
  repeated KubernetesAPIResult results = 2;
  
  // Any global error message (e.g., auth failure, operator issues)
  string global_error_message = 3;
}

// Shell command request message for executing shell commands
message ShellCommandRequest {
  // Unique identifier for tracking this request
  string request_id = 1;
  
  // List of shell commands to execute
  repeated string commands = 2;
  
  // Optional timeout for the entire batch (in seconds)
  int32 timeout_seconds = 3;
}

// Individual shell command result
message ShellCommandResult {
  // The command that was executed
  string command = 1;
  
  // Whether this command succeeded (exit code 0)
  bool success = 2;
  
  // Standard output from the command
  string stdout = 3;
  
  // Standard error from the command  
  string stderr = 4;
  
  // Exit code returned by the command
  int32 exit_code = 5;
}

// Shell command response message containing results
message ShellCommandResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Results for each individual shell command
  repeated ShellCommandResult results = 2;
  
  // Any global error message (e.g., operator issues)
  string global_error_message = 3;
}

// YAML dry-run validation request message
message YamlDryRunRequest {
  // Unique identifier for tracking this request
  string request_id = 1;
  
  // List of YAML manifests to validate
  repeated YamlManifest yaml_manifests = 2;
  
  // Optional timeout for the entire batch (in seconds)
  int32 timeout_seconds = 3;
}

// Individual YAML manifest for validation
message YamlManifest {
  // Unique identifier for this manifest
  string manifest_id = 1;
  
  // YAML content to validate
  string yaml_content = 2;
  
  // Optional resource type hint (Deployment, Service, etc.)
  string resource_type = 3;
  
  // Optional namespace (for namespaced resources)
  string namespace = 4;
}

// Individual YAML validation result
message YamlValidationResult {
  // The manifest ID that was validated
  string manifest_id = 1;
  
  // Whether this manifest passed dry-run validation
  bool valid = 2;
  
  // Error message if validation failed
  string error_message = 3;
  
  // HTTP status code from Kubernetes API
  int32 status_code = 4;
  
  // Suggested fixes (if any)
  string suggested_fix = 5;
}

// YAML dry-run validation response message
message YamlDryRunResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Results for each individual YAML manifest
  repeated YamlValidationResult results = 2;
  
  // Any global error message (e.g., operator issues)
  string global_error_message = 3;
}

// YAML apply request message
message YamlApplyRequest {
  // Unique identifier for tracking this request
  string request_id = 1;
  
  // List of YAML manifests to apply
  repeated YamlManifest yaml_manifests = 2;
  
  // Optional timeout for the entire batch (in seconds)
  int32 timeout_seconds = 3;
}

// Individual YAML application result
message YamlApplyResult {
  // The manifest ID that was applied
  string manifest_id = 1;
  
  // Whether this manifest was successfully applied
  bool success = 2;
  
  // Error message if application failed
  string error_message = 3;
  
  // HTTP status code from Kubernetes API
  int32 status_code = 4;
  
  // Applied resource information (if successful)
  string applied_resource_info = 5;
}

// YAML apply response message
message YamlApplyResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Results for each individual YAML manifest
  repeated YamlApplyResult results = 2;
  
  // Any global error message (e.g., operator issues)
  string global_error_message = 3;
}

// L7AccessLog message for streaming L7 access logs from Envoy
message L7AccessLog {
  // Timestamp when the request was received
  google.protobuf.Timestamp timestamp = 1;
  
  // Source information
  L7Endpoint source = 2;
  
  // Destination information  
  L7Endpoint destination = 3;
  
  // Protocol information
  string protocol = 4; // TCP, UDP
  
  // L7 protocol type
  L7ProtocolType l7_protocol = 5;
  
  // HTTP-specific data (when l7_protocol is HTTP)
  HTTPAccessLogData http_data = 6;
  
  // TCP-specific data (when l7_protocol is TCP)
  TCPAccessLogData tcp_data = 7;
  
  // Duration of the request/connection
  int64 duration_ms = 8;
  
  // Number of bytes sent upstream
  uint64 bytes_sent = 9;
  
  // Number of bytes received from upstream
  uint64 bytes_received = 10;
  
  // Whether the request was successful
  bool allowed = 11;
  
  // Node ID from Envoy
  string node_id = 12;
  
  // Cluster name from Envoy
  string cluster_name = 13;
  
  // Count of times this L7 access log was observed
  int64 count = 14;
  
  // When this L7 access log was first seen
  google.protobuf.Timestamp first_seen = 15;
  
  // When this L7 access log was last seen
  google.protobuf.Timestamp last_seen = 16;
}

// L7 protocol types
enum L7ProtocolType {
  L7_PROTOCOL_UNKNOWN = 0;
  L7_PROTOCOL_HTTP = 1;
  L7_PROTOCOL_TCP = 2;
  L7_PROTOCOL_GRPC = 3;
}

// L7 endpoint information with richer metadata than basic Endpoint
message L7Endpoint {
  // IP address
  string ip = 1;
  
  // Port number
  uint32 port = 2;
  
  // Kubernetes namespace
  string namespace = 3;
  
  // Kubernetes workload kind (Pod, Service, etc.)
  string kind = 4;
  
  // Kubernetes workload name
  string name = 5;
  
  // Service name (if applicable)
  string service_name = 6;
}

// HTTP-specific access log data
message HTTPAccessLogData {
  // HTTP method (GET, POST, etc.)
  string method = 1;
  
  // Request path
  string path = 2;
  
  // HTTP version (e.g., "1.1", "2.0")
  string version = 3;
  
  // Host header value
  string host = 4;
  
  // User agent header
  string user_agent = 5;
  
  // Request headers
  map<string, string> request_headers = 6;
  
  // Response status code
  uint32 response_code = 7;
  
  // Response headers
  map<string, string> response_headers = 8;
  
  // Request size in bytes
  uint64 request_size = 9;
  
  // Response size in bytes
  uint64 response_size = 10;
  
  // Referer header
  string referer = 11;
  
  // Response flags from Envoy
  repeated string response_flags = 12;
  
  // Connection termination details (from CommonProperties)
  string connection_termination_details = 13;
  
  // Transport failure reason (if connection failed)
  string upstream_transport_failure_reason = 14;
  
  // Downstream transport failure reason (if applicable)
  string downstream_transport_failure_reason = 15;
  
  // Access log type (e.g., "DownstreamStart", "DownstreamEnd")
  string access_log_type = 16;
  
  // Optional unique stream/connection ID
  string stream_id = 17;
  
  // Number of upstream connection attempts
  uint32 upstream_request_attempt_count = 18;
}

// TCP-specific access log data
message TCPAccessLogData {
  // Connection state (derived from access log type and termination details)
  string connection_state = 1;
  
  // Number of bytes received from downstream
  uint64 received_bytes = 2;
  
  // Number of bytes sent to downstream  
  uint64 sent_bytes = 3;
  
  // Connection termination details
  string connection_termination_details = 4;
  
  // Transport failure reason (if connection failed)
  string upstream_transport_failure_reason = 5;
  
  // Downstream transport failure reason (if applicable)
  string downstream_transport_failure_reason = 6;
  
  // Access log type (e.g., "TcpUpstreamConnected", "TcpConnectionEnd")
  string access_log_type = 7;
  
  // Optional unique stream/connection ID
  string stream_id = 8;
  
  // Number of upstream connection attempts
  uint32 upstream_request_attempt_count = 9;
}

// Istio Authorization Policy definition
message AuthorizationPolicy {
  string api_version = 1; // security.istio.io/v1beta1, security.istio.io/v1, etc.
  string kind = 2;

  // Standard Kubernetes metadata
  ObjectMeta metadata = 3;
  AuthorizationPolicySpec spec = 4;

  // Zero-or-more "target" workloads protected by this policy;
  // each entry in the target_workloads list is of the format: "<Namespace>.<Kind>.<Name>".
  repeated string target_workloads = 5;

  // Action performed on this authorization policy
  Action action = 6; // CREATE, UPDATE, DELETE
}

// Authorization Policy specification
message AuthorizationPolicySpec {
  // Optional. The selector decides where to apply the authorization policy.
  LabelSelector selector = 1;

  // Optional. A list of rules to match the request.
  repeated AuthorizationPolicyRule rules = 2;

  // Optional. The action to take if the request is matched with the rules.
  AuthorizationPolicyAction action = 3;
}

// Authorization Policy rule
message AuthorizationPolicyRule {
  // Optional. from specifies the source of a request.
  repeated AuthorizationPolicyRuleFrom from = 1;

  // Optional. to specifies the operation of a request.
  repeated AuthorizationPolicyRuleTo to = 2;

  // Optional. when specifies a list of additional conditions of a request.
  repeated AuthorizationPolicyCondition when = 3;
}

// Authorization Policy rule from
message AuthorizationPolicyRuleFrom {
  // Optional. source specifies the source identities of a request.
  AuthorizationPolicySource source = 1;
}

// Authorization Policy rule to
message AuthorizationPolicyRuleTo {
  // Optional. operation specifies the operation of a request.
  AuthorizationPolicyOperation operation = 1;
}

// Authorization Policy source
message AuthorizationPolicySource {
  // Optional. A list of source peer identities (i.e. service account).
  repeated string principals = 1;

  // Optional. A list of request identities (i.e. request.auth.principal).
  repeated string request_principals = 2;

  // Optional. A list of namespaces.
  repeated string namespaces = 3;

  // Optional. A list of IP blocks.
  repeated string ip_blocks = 4;

  // Optional. A list of remote IP blocks.
  repeated string remote_ip_blocks = 5;
}

// Authorization Policy operation
message AuthorizationPolicyOperation {
  // Optional. A list of HTTP methods (e.g., "GET", "POST").
  repeated string methods = 1;

  // Optional. A list of HTTP paths or gRPC methods.
  repeated string paths = 2;

  // Optional. A list of ports.
  repeated string ports = 3;

  // Optional. A list of hosts.
  repeated string hosts = 4;
}

// Authorization Policy condition
message AuthorizationPolicyCondition {
  // The name of an Istio attribute.
  string key = 1;

  // Optional. A list of allowed values for the attribute.
  repeated string values = 2;

  // Optional. A list of allowed values for the attribute specified as a regular expression.
  repeated string not_values = 3;
}

// Authorization Policy action
enum AuthorizationPolicyAction {
  AUTHORIZATION_POLICY_ACTION_UNSPECIFIED = 0;
  AUTHORIZATION_POLICY_ACTION_ALLOW = 1;
  AUTHORIZATION_POLICY_ACTION_DENY = 2;
  AUTHORIZATION_POLICY_ACTION_AUDIT = 3;
  AUTHORIZATION_POLICY_ACTION_CUSTOM = 4;
}

// Certificate renewal request message
message CertificateRenewalRequest {
  // Unique identifier for tracking this renewal request
  string request_id = 1;
  
  // New client certificate (base64-encoded PEM data)
  string client_cert = 2;
  
  // New client private key (base64-encoded PEM data)
  string client_key = 3;
  
  // CA certificate for server verification (base64-encoded PEM data)
  string ca_cert = 4;
  
  // When the new certificate was issued
  google.protobuf.Timestamp issued_at = 5;
  
  // When the new certificate expires
  google.protobuf.Timestamp expires_at = 6;
  
  // Certificate serial number for tracking
  string serial_number = 7;
}

// Certificate renewal response message
message CertificateRenewalResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Whether the certificate renewal was successful
  bool success = 2;
  
  // Error message if renewal failed
  string error_message = 3;
  
  // When the certificate was successfully applied
  google.protobuf.Timestamp applied_at = 4;
}

// Operator restart request message
message OperatorRestartRequest {
  // Unique identifier for tracking this restart request
  string request_id = 1;
  
  // Reason for the restart (for logging purposes)
  string reason = 2;
  
  // Optional delay before restart (in seconds)
  int32 delay_seconds = 3;
  
  // Whether to perform a graceful restart (default: true)
  bool graceful = 4;
}

// Operator restart response message
message OperatorRestartResponse {
  // Request identifier that matches the request
  string request_id = 1;
  
  // Whether the restart was initiated successfully
  bool success = 2;
  
  // Error message if restart failed
  string error_message = 3;
  
  // When the restart was initiated
  google.protobuf.Timestamp initiated_at = 4;
}

// Kubernetes Event message for incident detection
message KubernetesEvent {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  
  // Event metadata
  string event_type = 4; // Normal, Warning
  string reason = 5; // FailedScheduling, Unhealthy, FailedMount, etc.
  string message = 6; // Detailed event message
  
  // Involved object (what the event is about)
  ObjectReference involved_object = 7;
  
  // Event source
  EventSource source = 8;
  
  // Event timing
  google.protobuf.Timestamp first_timestamp = 9;
  google.protobuf.Timestamp last_timestamp = 10;
  int32 count = 11; // How many times this event occurred
  
  // Action performed on this event
  Action action = 12; // CREATE, UPDATE, DELETE
}

// Object reference for events
message ObjectReference {
  string kind = 1; // Pod, Deployment, Node, etc.
  string namespace = 2;
  string name = 3;
  string uid = 4;
  string api_version = 5;
  string resource_version = 6;
  string field_path = 7;
}

// Event source information
message EventSource {
  string component = 1; // kubelet, default-scheduler, etc.
  string host = 2; // Node hostname
}

// Pod status change message for incident detection
message PodStatusChange {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  string pod_ip = 4;
  string node_name = 5;
  
  // Pod phase
  string phase = 6; // Pending, Running, Succeeded, Failed, Unknown
  
  // Container statuses
  repeated ContainerStatus container_statuses = 7;
  repeated ContainerStatus init_container_statuses = 8;
  
  // Conditions
  repeated PodCondition conditions = 9;
  
  // QoS class
  string qos_class = 10; // Guaranteed, Burstable, BestEffort
  
  // Restart count (sum of all container restarts)
  int32 total_restart_count = 11;
  
  // Resource usage at the time of status change (if available)
  ResourceUsage resource_usage = 12;
  
  // Owner references
  repeated OwnerReference owner_references = 13;
  
  // Timestamps
  google.protobuf.Timestamp created_at = 14;
  google.protobuf.Timestamp status_timestamp = 15;
  
  // Action performed
  Action action = 16; // CREATE, UPDATE, DELETE
}

// Container status within a pod
message ContainerStatus {
  string name = 1;
  string image = 2;
  string image_id = 3;
  string container_id = 4;
  
  bool ready = 5;
  int32 restart_count = 6;
  
  // Current state
  ContainerState state = 7;
  
  // Last terminated state (if container was terminated)
  ContainerState last_termination_state = 8;
  
  bool started = 9;
}

// Container state (waiting, running, or terminated)
message ContainerState {
  oneof state {
    ContainerStateWaiting waiting = 1;
    ContainerStateRunning running = 2;
    ContainerStateTerminated terminated = 3;
  }
}

// Container waiting state
message ContainerStateWaiting {
  string reason = 1; // CrashLoopBackOff, ImagePullBackOff, ErrImagePull, etc.
  string message = 2;
}

// Container running state
message ContainerStateRunning {
  google.protobuf.Timestamp started_at = 1;
}

// Container terminated state
message ContainerStateTerminated {
  int32 exit_code = 1;
  int32 signal = 2;
  string reason = 3; // OOMKilled, Error, Completed, etc.
  string message = 4;
  google.protobuf.Timestamp started_at = 5;
  google.protobuf.Timestamp finished_at = 6;
  string container_id = 7;
}

// Pod condition
message PodCondition {
  string type = 1; // Ready, Initialized, ContainersReady, PodScheduled
  string status = 2; // True, False, Unknown
  google.protobuf.Timestamp last_probe_time = 3;
  google.protobuf.Timestamp last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// Resource usage metrics
message ResourceUsage {
  int64 cpu_usage_nano_cores = 1;
  int64 memory_usage_bytes = 2;
  int64 cpu_limit_nano_cores = 3;
  int64 memory_limit_bytes = 4;
  int64 cpu_request_nano_cores = 5;
  int64 memory_request_bytes = 6;
}

// Node condition change message for incident detection
message NodeConditionChange {
  string name = 1;
  string uid = 2;
  
  // Node conditions
  repeated NodeCondition conditions = 3;
  
  // Node addresses
  repeated string internal_ips = 4;
  repeated string external_ips = 5;
  string hostname = 6;
  
  // Node info
  string instance_type = 7;
  string zone = 8;
  
  // Resource capacity and allocatable
  map<string, string> capacity = 9; // cpu, memory, pods, etc.
  map<string, string> allocatable = 10;
  
  // Timestamps
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp condition_timestamp = 12;
  
  // Action performed
  Action action = 13; // CREATE, UPDATE, DELETE
}

// Node condition
message NodeCondition {
  string type = 1; // Ready, MemoryPressure, DiskPressure, PIDPressure, NetworkUnavailable
  string status = 2; // True, False, Unknown
  google.protobuf.Timestamp last_heartbeat_time = 3;
  google.protobuf.Timestamp last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// Workload rollout status message for incident detection
message WorkloadRolloutStatus {
  string name = 1;
  string namespace = 2;
  string uid = 3;
  string kind = 4; // Deployment, StatefulSet, DaemonSet
  
  // Rollout status
  string rollout_status = 5; // Progressing, Complete, Failed, TimedOut
  string rollout_reason = 6; // ProgressDeadlineExceeded, NewReplicaSetAvailable, etc.
  string rollout_message = 7;
  
  // Replica information
  int32 desired_replicas = 8;
  int32 current_replicas = 9;
  int32 ready_replicas = 10;
  int32 available_replicas = 11;
  int32 updated_replicas = 12;
  int32 unavailable_replicas = 13;
  
  // Conditions
  repeated WorkloadCondition conditions = 14;
  
  // Observed generation for rollout tracking
  int64 observed_generation = 15;
  int64 metadata_generation = 16;
  
  // Timestamps
  google.protobuf.Timestamp created_at = 17;
  google.protobuf.Timestamp status_timestamp = 18;
  
  // Action performed
  Action action = 19; // CREATE, UPDATE, DELETE
}

// Workload condition
message WorkloadCondition {
  string type = 1; // Available, Progressing, ReplicaFailure (Deployment); PartitionRollout (StatefulSet)
  string status = 2; // True, False, Unknown
  google.protobuf.Timestamp last_update_time = 3;
  google.protobuf.Timestamp last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// Pod logs message for incident investigation and root cause analysis
message PodLogs {
  string pod_name = 1;
  string namespace = 2;
  string pod_uid = 3;
  string container_name = 4;
  
  // Log entries (batched for efficiency)
  repeated LogEntry log_entries = 5;
  
  // Whether these are logs from a previous container instance (for crashed containers)
  bool previous_container = 6;
  
  // Log metadata
  google.protobuf.Timestamp collection_timestamp = 7;
  int64 total_lines = 8; // Total lines in this batch
  
  // Log streaming control
  bool stream_complete = 9; // True if this is the last batch for this pod/container
  int64 stream_offset = 10; // Offset for pagination/continuation
  
  // Owner references for correlation with incidents
  repeated OwnerReference owner_references = 11;
  
  // Node where pod is running (for correlation)
  string node_name = 12;
}

// Individual log entry with metadata
message LogEntry {
  google.protobuf.Timestamp timestamp = 1; // Log timestamp (parsed if available)
  string message = 2; // Actual log message
  string level = 3; // Log level (ERROR, WARN, INFO, DEBUG) - parsed if detectable
  int64 line_number = 4; // Line number in the log stream
  
  // Parsed error information (if detected)
  LogErrorInfo error_info = 5;
}

// Error information parsed from log entries
message LogErrorInfo {
  string error_type = 1; // OutOfMemoryException, NullPointerException, SegmentationFault, etc.
  string stack_trace = 2; // Stack trace if available
  string error_message = 3; // Detailed error message
  int32 exit_code = 4; // Exit code if this log indicates termination
}

// ============================================================================
// OTEL Metrics Storage Messages
// ============================================================================

// Metrics query request from server to operator
message MetricsQueryRequest {
  // Unique identifier for tracking this request
  string request_id = 1;

  // Filters (all optional - empty means "all")
  string namespace = 2;
  string workload_name = 3;
  string workload_kind = 4;       // Deployment, StatefulSet, DaemonSet
  string pod_name = 5;            // Direct pod name filter
  string pod_name_prefix = 6;     // Pod name prefix for pattern matching
  repeated string metric_names = 7;
  map<string, string> label_matchers = 8;  // Additional label filters

  // Time range (required)
  google.protobuf.Timestamp start_time = 9;
  google.protobuf.Timestamp end_time = 10;

  // Pagination/limits
  int32 max_series = 11;          // Max number of series to return (0 = unlimited)
  int32 max_data_points = 12;     // Max data points per series (0 = unlimited)
}

// Metrics query response from operator to server
message MetricsQueryResponse {
  // Request identifier that matches the request
  string request_id = 1;

  // Query results
  repeated OTelMetric metrics = 2;

  // Response metadata
  int32 total_series_matched = 3;
  int32 total_series_returned = 4;
  bool truncated = 5;             // True if results were limited by max_series

  // Error information
  string error_message = 6;
}

// Individual metric with its data points
message OTelMetric {
  // Metric identity
  string name = 1;
  string description = 2;
  string unit = 3;
  OTelMetricType type = 4;

  // Kubernetes context
  string namespace = 5;
  string workload_name = 6;
  string workload_kind = 7;
  string pod_name = 8;
  string container_name = 9;
  string node_name = 10;

  // Labels/attributes (excluding K8s context)
  map<string, string> labels = 11;

  // Time-series data points
  repeated OTelMetricDataPoint data_points = 12;

  // Instrumentation scope
  string scope_name = 13;
  string scope_version = 14;
}

// Buckets for exponential histogram (positive or negative)
message ExponentialHistogramBuckets {
  int32 offset = 1;                     // Starting bucket index
  repeated uint64 bucket_counts = 2;    // Count per bucket
}

// Data specific to exponential histograms
message ExponentialHistogramData {
  int32 scale = 1;                              // Scale factor for bucket boundaries
  uint64 zero_count = 2;                        // Count of values exactly at zero
  double zero_threshold = 3;                    // Threshold for zero bucket
  ExponentialHistogramBuckets positive = 4;    // Positive value buckets
  ExponentialHistogramBuckets negative = 5;    // Negative value buckets
}

// Single quantile value for summary metrics
message QuantileValue {
  double quantile = 1;    // Quantile (0.0 to 1.0, e.g., 0.5 for median, 0.99 for p99)
  double value = 2;       // Value at this quantile
}

// Data specific to summary metrics
message SummaryData {
  repeated QuantileValue quantile_values = 1;  // Pre-computed quantiles
}

// Individual data point in a time series
message OTelMetricDataPoint {
  // Timestamps
  google.protobuf.Timestamp timestamp = 1;
  google.protobuf.Timestamp start_timestamp = 2;

  // Value (for Gauge and Sum types)
  double value = 3;

  // Histogram fields (for Histogram and ExponentialHistogram types)
  repeated double bucket_bounds = 4;    // Explicit bucket boundaries
  repeated uint64 bucket_counts = 5;    // Count per bucket
  uint64 count = 6;                     // Total count
  double sum = 7;                       // Sum of all values
  double min = 8;                       // Minimum value
  double max = 9;                       // Maximum value

  // Point-level attributes (if different from series labels)
  map<string, string> attributes = 10;

  // Exponential histogram specific data (for EXPONENTIAL_HISTOGRAM type)
  ExponentialHistogramData exponential_histogram = 11;

  // Summary specific data (for SUMMARY type)
  SummaryData summary = 12;
}

// Metric type enumeration
enum OTelMetricType {
  OTEL_METRIC_TYPE_UNSPECIFIED = 0;
  OTEL_METRIC_TYPE_GAUGE = 1;
  OTEL_METRIC_TYPE_SUM = 2;
  OTEL_METRIC_TYPE_HISTOGRAM = 3;
  OTEL_METRIC_TYPE_EXPONENTIAL_HISTOGRAM = 4;
  OTEL_METRIC_TYPE_SUMMARY = 5;
}

// Batch of metrics (used internally for OTEL receiver â†’ store)
message OTelMetricBatch {
  repeated OTelMetric metrics = 1;
  google.protobuf.Timestamp received_at = 2;
  int32 metric_count = 3;
}


// Service definition with bi-directional streaming RPC
service StreamService {
  // Bi-directional streaming RPC
  rpc StreamData(stream StreamDataRequest) returns (stream StreamDataResponse) {}
}
